#include <cstdlib>
#include "uint256.h"
#include "crypto/verus_clhash.h"

#if defined(__APPLE__) || defined(_WIN32)
// attempt to workaround horrible mingw/gcc destructor bug on Windows and Mac, which passes garbage in the this pointer
// we use the opportunity of control here to clean up all of our tls variables. we could keep a list, but this is a safe,
// functional hack
thread_specific_ptr::~thread_specific_ptr() {
    if (verusclhasher_key.ptr)
    {
        verusclhasher_key.reset();
    }
    if (verusclhasher_descr.ptr)
    {
        verusclhasher_descr.reset();
    }
}
#endif // defined(__APPLE__) || defined(_WIN32)

/*
The function `_GLOBAL__sub_I_verus_clhash_tsp.cpp` is generated by the compiler to initialize global static objects before `main()` runs. 
However, the compiler generates it using `vxorps` and `vmovups` instructions, which rely on AVX (Advanced Vector Extensions) 
and are thus problematic on Apple Silicon under Rosetta. Here’s an example output:

otool -tv ./src/verus | grep -E 'vaddps|vmulps|vsubps|vdivps|vaddss|vmulss|avx512|vmovups|vxorps' -A 2 -B 2

```asm
__GLOBAL__sub_I_verus_clhash_tsp.cpp:
000000010007d1d0	pushq	%rax
000000010007d1d1	vxorps	%xmm0, %xmm0, %xmm0
000000010007d1d5	vmovups	%ymm0, 0x90b73(%rip)
000000010007d1dd	leaq	0x90b6c(%rip), %rdi
000000010007d1e4	leaq	0x50d2c(%rip), %rsi
```

Our goal is to eliminate any AVX instructions in the initialization code. Otherwise, we’ll encounter an "Illegal Hardware Instruction" 
error when running under Rosetta on Apple Silicon, as described https://medium.com/macoclock/m1-rosetta-2-limitation-illegal-hardware-instruction-a3b48fae02e .
*/

#ifdef   __clang__
#pragma clang optimize off
#endif

int __cpuverusoptimized = 0x80;
thread_local thread_specific_ptr verusclhasher_key;
thread_local thread_specific_ptr verusclhasher_descr;

#ifdef   __clang__
#pragma clang optimize on
#endif
